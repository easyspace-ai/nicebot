<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket Limit Order Bot</title>
    <style>
        /* Palette and typography */
        :root {
            --bg: #05070d;
            --panel: rgba(18, 24, 40, 0.72);
            --panel-strong: rgba(14, 18, 30, 0.9);
            --border: rgba(99, 123, 169, 0.25);
            --glow: 0 10px 40px rgba(0, 255, 209, 0.08), 0 0 60px rgba(90, 178, 255, 0.12);
            --text: #eef2ff;
            --muted: #9fb0d1;
            --accent: #4af1c8;
            --accent-2: #7c8bff;
            --danger: #ff6b9a;
            --warning: #f2c94c;
            --success: #4af1c8;
            --badge-bg: rgba(124, 139, 255, 0.1);
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Inter", "DM Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at 10% 10%, rgba(74, 241, 200, 0.08), transparent 25%),
                        radial-gradient(circle at 85% 0%, rgba(124, 139, 255, 0.12), transparent 30%),
                        linear-gradient(135deg, #05070d 0%, #070b14 50%, #05070d 100%);
            color: var(--text);
            padding: 24px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2rem;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--muted);
            margin-top: 6px;
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 14px;
        }

        .btn {
            background: var(--panel-strong);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.18s ease;
            box-shadow: var(--glow);
        }

        .btn.accent {
            background: linear-gradient(120deg, var(--accent), var(--accent-2));
            color: #05070d;
            border: none;
            box-shadow: 0 10px 30px rgba(74, 241, 200, 0.25);
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.01);
            border-color: var(--accent);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .card {
            position: relative;
            background: var(--panel);
            border-radius: 14px;
            padding: 16px;
            overflow: hidden;
            backdrop-filter: blur(16px);
            box-shadow: var(--glow);
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 14px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(74, 241, 200, 0.35), rgba(124, 139, 255, 0.35));
            mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            mask-composite: exclude;
            -webkit-mask-composite: destination-out;
            pointer-events: none;
        }

        .card-title {
            font-size: 0.9rem;
            color: var(--muted);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .metric {
            font-size: 1.7rem;
            font-weight: 700;
        }

        .metric.badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 1rem;
            background: radial-gradient(circle at 10% 10%, rgba(74, 241, 200, 0.2), rgba(124, 139, 255, 0.15));
            border: 1px solid var(--border);
            box-shadow: var(--glow);
        }

        .badge-chip {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.04);
            box-shadow: var(--glow);
        }

        .badge-chip.success { background: rgba(74, 241, 200, 0.16); color: var(--success); }
        .badge-chip.warning { background: rgba(242, 201, 76, 0.18); color: var(--warning); }
        .badge-chip.danger { background: rgba(255, 107, 154, 0.18); color: var(--danger); }
        .badge-chip.neutral { background: rgba(124, 139, 255, 0.1); color: var(--text); }

        .section {
            background: var(--panel-strong);
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 16px;
            box-shadow: var(--glow);
            border: 1px solid var(--border);
            backdrop-filter: blur(20px);
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .table-wrap {
            overflow-x: auto;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.02);
            box-shadow: var(--glow);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 680px;
        }

        th, td {
            padding: 12px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            position: sticky;
            top: 0;
            background: var(--panel-strong);
            z-index: 1;
            font-size: 0.9rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        tr:hover td {
            background: rgba(124, 139, 255, 0.06);
        }

        a.market-link {
            color: var(--accent-2);
            text-decoration: none;
            font-weight: 600;
        }

        .countdown {
            font-weight: 700;
            color: var(--accent-2);
            letter-spacing: 0.04em;
        }

        .countdown.soon {
            color: var(--danger);
        }

        .logs {
            background: var(--panel-strong);
            border-radius: 12px;
            padding: 14px;
            max-height: 360px;
            overflow-y: auto;
            font-family: "DM Mono", "SFMono-Regular", Consolas, monospace;
            font-size: 0.9rem;
            border: 1px solid var(--border);
            box-shadow: var(--glow);
        }

        .log-line { margin-bottom: 6px; color: #cdd6e8; }
        .log-line.error { color: var(--danger); }
        .log-line.warning { color: var(--warning); }
        .log-line.info { color: var(--accent-2); }

        .loop-bar {
            position: relative;
            height: 12px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid var(--border);
            margin-top: 10px;
        }

        .loop-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            box-shadow: 0 0 20px rgba(74, 241, 200, 0.35);
            transition: width 0.3s ease;
        }

        .empty-state {
            text-align: center;
            color: var(--muted);
            padding: 24px;
            font-weight: 600;
        }

        .banner {
            border-radius: 12px;
            padding: 14px 16px;
            margin: 10px 0 18px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.03);
            box-shadow: var(--glow);
        }

        .banner.warning { background: rgba(242, 201, 76, 0.14); border-color: rgba(242, 201, 76, 0.4); color: var(--warning); }
        .banner.success { background: rgba(74, 241, 200, 0.12); border-color: rgba(74, 241, 200, 0.4); color: var(--success); }

        @media (max-width: 900px) {
            table { min-width: 0; }
            th, td { font-size: 0.9rem; }
            .grid { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        }

        /* Mobile stacking for tables */
        @media (max-width: 720px) {
            .table-wrap table,
            .table-wrap thead,
            .table-wrap tbody,
            .table-wrap th,
            .table-wrap td,
            .table-wrap tr {
                display: block;
                width: 100%;
            }
            .table-wrap thead {
                display: none;
            }
            .table-wrap tr {
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 10px 12px;
                margin-bottom: 12px;
                background: var(--card-strong);
            }
            .table-wrap td {
                border: none;
                padding: 6px 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }
            .table-wrap td::before {
                content: attr(data-label);
                color: var(--muted);
                font-size: 0.85rem;
                font-weight: 600;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Polymarket Limit Order Bot</h1>
            <p class="subtitle">Automated liquidity provision for BTC 15-minute markets</p>
            <div class="controls">
                <button class="btn accent" onclick="updateAll()">Refresh now</button>
                <button class="btn" onclick="copySnapshot()">Copy snapshot</button>
            </div>
        </header>

        <div class="grid">
            <div class="card">
                <div class="card-title">Status</div>
                <div class="metric badge" id="status">Loading...</div>
            </div>
            <div class="card">
                <div class="card-title">USDC Balance</div>
                <div class="metric" id="balance">$0.00</div>
            </div>
            <div class="card">
                <div class="card-title">Active Markets</div>
                <div class="metric" id="markets-count">0</div>
            </div>
            <div class="card">
                <div class="card-title">Pending Orders</div>
                <div class="metric" id="orders-count">0</div>
            </div>
            <div class="card">
                <div class="card-title">Last Check</div>
                <div class="metric" id="last-check">Never</div>
            </div>
            <div class="card">
                <div class="card-title">Bot Loop</div>
                <div class="metric" id="loop-next">--</div>
                <div class="subtitle" id="loop-eta">Next run in --</div>
                <div class="loop-bar">
                    <div class="loop-fill" id="loop-progress"></div>
                </div>
            </div>
        </div>

        <div id="balance-warning" class="banner warning" style="display:none;">
            <strong>Low Balance</strong>
            <div id="balance-warning-message" style="margin-top: 6px;"></div>
        </div>

        <div class="section">
            <div class="section-title">Trade Statistics</div>
            <div class="grid">
                <div class="card">
                    <div class="card-title">Markets Participated</div>
                    <div class="metric" id="total-markets">0</div>
                </div>
                <div class="card">
                    <div class="card-title">Successful Trades</div>
                    <div class="metric" id="successful-trades">0</div>
                    <div class="badge-chip success">Both orders filled</div>
                </div>
                <div class="card">
                    <div class="card-title">Unsuccessful Trades</div>
                    <div class="metric" id="unsuccessful-trades">0</div>
                    <div class="badge-chip danger">None or one fill</div>
                </div>
                <div class="card">
                    <div class="card-title">Total PNL</div>
                    <div class="metric" id="total-pnl">$0.00</div>
                    <div class="badge-chip" id="pnl-badge">--</div>
                </div>
            </div>
        </div>

        <!-- Strategy Statistics Section -->
        <div class="section">
            <div class="section-title">Strategy Statistics</div>
            <div id="strategy-stats-content">
                <div class="empty-state">Loading strategy statistics...</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Upcoming BTC 15-Minute Markets</div>
            <div id="markets-content">
                <div class="empty-state">Loading markets...</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Open Orders</div>
            <div id="pending-orders-content">
                <div class="empty-state">Loading orders...</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Order History (Last 100)</div>
            <div id="recent-orders-content">
                <div class="empty-state">Loading orders...</div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Bot Logs</div>
            <div class="logs" id="logs-content">
                <div class="log-line">Loading logs...</div>
            </div>
        </div>

        <div class="subtitle" style="text-align:center; margin-top: 8px;">Auto-refreshing every 5 seconds</div>
    </div>

    <script>
        function formatTime(isoString) {
            if (!isoString) return 'N/A';
            const date = new Date(isoString);
            return date.toLocaleTimeString();
        }

        function formatDateTime(isoString) {
            if (!isoString) return 'N/A';
            const date = new Date(isoString);
            return date.toLocaleString();
        }

        function setStatusBadge(isRunning) {
            const el = document.getElementById('status');
            el.className = 'metric badge';
            if (isRunning) {
                el.textContent = 'Running';
                el.classList.add('badge-chip', 'success');
            } else {
                el.textContent = 'Stopped';
                el.classList.add('badge-chip', 'danger');
            }
        }

        async function copySnapshot() {
            try {
                const [statusRes, ordersRes, marketsRes, logsRes] = await Promise.all([
                    fetch('/api/status').then(r => r.json()),
                    fetch('/api/orders').then(r => r.json()),
                    fetch('/api/markets').then(r => r.json()),
                    fetch('/api/logs').then(r => r.json())
                ]);

                const snapshot = {
                    status: statusRes,
                    pending_orders: ordersRes.pending_orders?.length || 0,
                    recent_orders: ordersRes.recent_orders?.length || 0,
                    markets: marketsRes.markets?.length || 0,
                    logs_tail: (logsRes.logs || []).slice(-50)
                };

                await navigator.clipboard.writeText(JSON.stringify(snapshot, null, 2));
                alert('Snapshot copied to clipboard');
            } catch (e) {
                console.error('Snapshot copy failed', e);
                alert('Could not copy snapshot');
            }
        }

        function formatCountdown(startIso) {
            if (!startIso) return 'N/A';
            const target = new Date(startIso).getTime();
            const now = Date.now();
            const diffMs = target - now;
            const negative = diffMs < 0;
            const abs = Math.abs(diffMs);
            const minutes = Math.floor(abs / 60000);
            const seconds = Math.floor((abs % 60000) / 1000);
            const pad = (n) => n.toString().padStart(2, '0');
            return `${negative ? '-' : ''}${pad(minutes)}:${pad(seconds)}`;
        }

        function refreshCountdowns() {
            document.querySelectorAll('.countdown-live').forEach(el => {
                const startIso = el.dataset.start;
                const formatted = formatCountdown(startIso);
                el.textContent = formatted;
                const target = new Date(startIso).getTime();
                const diffMs = target - Date.now();
                if (diffMs <= 10 * 60 * 1000) {
                    el.classList.add('soon');
                } else {
                    el.classList.remove('soon');
                }
            });
        }

        let countdownTimer = null;
        let loopMeta = { last: null, next: null, interval: null };
        let isBotRunning = false;
        function ensureCountdownTimer() {
            if (countdownTimer) return;
            countdownTimer = setInterval(() => {
                refreshCountdowns();
                refreshLoopProgress();
            }, 1000);
        }

        async function updateStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();

                isBotRunning = data.is_running;
                setStatusBadge(data.is_running);
                document.getElementById('balance').textContent = `$${data.usdc_balance.toFixed(2)}`;
                document.getElementById('markets-count').textContent = data.active_markets_count;
                document.getElementById('orders-count').textContent = data.pending_orders_count;
                document.getElementById('last-check').textContent = data.last_check ? formatTime(data.last_check) : 'Never';

                // Loop progress data
                loopMeta = {
                    last: data.last_check,
                    next: data.next_check,
                    interval: data.check_interval_seconds
                };
                updateLoopUi();

                const warningDiv = document.getElementById('balance-warning');
                const warningMessage = document.getElementById('balance-warning-message');

                if (data.balance_warning) {
                    let message = `Current balance ($${data.usdc_balance.toFixed(2)}) is below the minimum needed ($${data.min_balance_needed.toFixed(2)}) to place orders.`;
                    if (data.balance_error_count > 0) {
                        message += `<br><strong>${data.balance_error_count}</strong> order(s) failed due to insufficient balance or allowance.`;
                    }
                    warningMessage.innerHTML = message;
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }

        async function updateMarkets() {
            try {
                const response = await fetch('/api/markets');
                const data = await response.json();
                const container = document.getElementById('markets-content');

                if (!data.markets || data.markets.length === 0) {
                    container.innerHTML = '<div class="empty-state">No upcoming markets found. The bot will continue polling every 60s.</div>';
                    return;
                }

                let html = '<div class="table-wrap"><table><thead><tr><th>Market</th><th>Starts</th><th>Countdown</th><th>Outcomes</th><th>Status</th></tr></thead><tbody>';

                for (const market of data.markets) {
                    const startIso = market.start_datetime;
                    const countdownText = startIso ? formatCountdown(startIso) : market.time_until_start_formatted;
                    const countdownClass = 'countdown countdown-live';
                    const statusBadge = market.orders_placed
                        ? '<span class="badge-chip success">Orders placed</span>'
                        : '<span class="badge-chip neutral">Waiting</span>';

                    let outcomesHtml = '';
                    for (const outcome of market.outcomes) {
                        if (outcome.best_bid && outcome.best_ask) {
                            outcomesHtml += `<div>${outcome.outcome}: $${outcome.best_bid.toFixed(2)} / $${outcome.best_ask.toFixed(2)}</div>`;
                        }
                    }

                    html += `
                            <tr>
                            <td data-label="Market">
                                <a class="market-link" href="https://polymarket.com/market/${market.market_slug}"
                                   target="_blank" rel="noopener noreferrer">
                                    ${market.question}
                                </a>
                                <div class="subtitle" style="margin-top: 4px;">${market.market_slug}</div>
                            </td>
                            <td data-label="Starts">${formatDateTime(market.start_datetime)}</td>
                            <td data-label="Countdown"><span class="${countdownClass}" data-start="${startIso || ''}">${countdownText}</span></td>
                            <td data-label="Outcomes">${outcomesHtml || 'Loading orderbook...'}</td>
                            <td data-label="Status">${statusBadge}</td>
                        </tr>
                    `;
                }

                html += '</tbody></table></div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error updating markets:', error);
            }
        }

        async function updateOrders() {
            try {
                const response = await fetch('/api/orders');
                const data = await response.json();

                const pendingContainer = document.getElementById('pending-orders-content');
                if (!data.pending_orders || data.pending_orders.length === 0) {
                    pendingContainer.innerHTML = '<div class="empty-state">No open orders</div>';
                } else {
                    let html = '<div class="table-wrap"><table><thead><tr><th>Market</th><th>Outcome</th><th>Side</th><th>Price</th><th>Size</th><th>Status</th><th>Strategy</th><th>Created</th></tr></thead><tbody>';
                    for (const order of data.pending_orders) {
                        const sideBadge = `<span class="badge-chip ${order.side.toLowerCase() === 'buy' ? 'success' : 'danger'}">${order.side}</span>`;
                        const statusBadge = `<span class="badge-chip ${
                            order.status.toLowerCase() === 'placed' ? 'neutral'
                            : order.status.toLowerCase() === 'filled' ? 'success'
                            : order.status.toLowerCase() === 'cancelled' ? 'warning'
                            : 'danger'
                        }">${order.status}</span>`;
                        const strategyLabel = order.strategy || 'None';
                        const strategyBadge = order.strategy
                            ? `<span class="badge-chip neutral">${strategyLabel}</span>`
                            : '<span class="badge-chip" style="opacity: 0.5;">N/A</span>';

                        html += `
                            <tr>
                                <td data-label="Market">${order.market_slug}</td>
                                <td data-label="Outcome">${order.outcome}</td>
                                <td data-label="Side">${sideBadge}</td>
                                <td data-label="Price">$${order.price.toFixed(3)}</td>
                                <td data-label="Size">${order.size.toFixed(2)} ($${order.size_usd.toFixed(2)})</td>
                                <td data-label="Status">${statusBadge}</td>
                                <td data-label="Strategy">${strategyBadge}</td>
                                <td data-label="Created">${formatTime(order.created_at)}</td>
                            </tr>
                        `;
                    }
                    html += '</tbody></table></div>';
                    pendingContainer.innerHTML = html;
                }

                await updateMarketHistory();
            } catch (error) {
                console.error('Error updating orders:', error);
            }
        }

        async function updateMarketHistory() {
            try {
                const response = await fetch('/api/market-history');
                const data = await response.json();

                const recentContainer = document.getElementById('recent-orders-content');
                if (!data.markets || data.markets.length === 0) {
                    recentContainer.innerHTML = '<div class="empty-state">No market history</div>';
                    return;
                }

                let html = '<div class="table-wrap"><table><thead><tr><th>Market</th><th>Status</th><th>Result</th><th>Size</th><th>PNL</th><th>Strategy</th><th>Created</th></tr></thead><tbody>';
                for (const market of data.markets) {
                    let statusClass = 'neutral';
                    if (market.status && market.status.startsWith('FILLED') && market.total_count > 0) {
                        if (market.filled_count === 0) {
                            statusClass = 'neutral';
                        } else if (market.filled_count < market.total_count) {
                            statusClass = 'warning';
                        } else {
                            statusClass = 'success';
                        }
                    } else if (market.status === 'PARTIALLY_FILLED') {
                        statusClass = 'warning';
                    } else if (market.status === 'CANCELLED' || market.status === 'FAILED') {
                        statusClass = 'danger';
                    }
                    const statusBadge = `<span class="badge-chip ${statusClass}">${market.status}</span>`;

                    const resultClass = market.result === 'SUCCESS' ? 'success'
                        : market.result === 'FAILED' ? 'danger'
                        : 'neutral';
                    const resultBadge = `<span class="badge-chip ${resultClass}">${market.result}</span>`;

                    const pnlClass = market.pnl > 0 ? 'success' : market.pnl < 0 ? 'danger' : 'neutral';
                    const pnlBadge = `<span class="badge-chip ${pnlClass}">$${market.pnl.toFixed(2)}</span>`;

                    const strategyBadge = `<span class="badge-chip neutral">${market.strategy}</span>`;

                    html += `
                        <tr>
                            <td data-label="Market">${market.market_slug}</td>
                            <td data-label="Status">${statusBadge}</td>
                            <td data-label="Result">${resultBadge}</td>
                            <td data-label="Size">$${market.total_cost.toFixed(2)}</td>
                            <td data-label="PNL">${pnlBadge}</td>
                            <td data-label="Strategy">${strategyBadge}</td>
                            <td data-label="Created">${formatTime(market.created_at)}</td>
                        </tr>
                    `;
                }
                html += '</tbody></table></div>';
                recentContainer.innerHTML = html;
            } catch (error) {
                console.error('Error updating market history:', error);
                document.getElementById('recent-orders-content').innerHTML =
                    '<div class="empty-state">Error loading market history</div>';
            }
        }

        async function updateLogs() {
            try {
                const response = await fetch('/api/logs');
                const data = await response.json();
                const container = document.getElementById('logs-content');
                const lines = (data.logs || []).slice(-200);

                if (lines.length === 0) {
                    container.innerHTML = '<div class="empty-state">No logs yet</div>';
                    return;
                }

                let html = '';
                for (const line of lines.reverse()) {
                    let className = 'log-line';
                    if (line.includes('ERROR')) className += ' error';
                    else if (line.includes('WARNING')) className += ' warning';
                    else if (line.includes('INFO')) className += ' info';
                    html += `<div class="${className}">${line}</div>`;
                }
                container.innerHTML = html;
                container.scrollTop = container.scrollHeight;
            } catch (error) {
                console.error('Error updating logs:', error);
            }
        }

        async function updateStatistics() {
            try {
                const response = await fetch('/api/statistics');
                const stats = await response.json();
                document.getElementById('total-markets').textContent = stats.total_markets;
                document.getElementById('successful-trades').textContent = stats.successful_trades;
                document.getElementById('unsuccessful-trades').textContent = stats.unsuccessful_trades;

                // Update PNL display
                const pnl = stats.total_pnl || 0;
                document.getElementById('total-pnl').textContent = `$${pnl.toFixed(2)}`;

                const pnlBadge = document.getElementById('pnl-badge');
                if (pnl > 0) {
                    pnlBadge.textContent = 'Profit';
                    pnlBadge.className = 'badge-chip success';
                } else if (pnl < 0) {
                    pnlBadge.textContent = 'Loss';
                    pnlBadge.className = 'badge-chip danger';
                } else {
                    pnlBadge.textContent = 'Break Even';
                    pnlBadge.className = 'badge-chip neutral';
                }
            } catch (error) {
                console.error('Error updating statistics:', error);
            }
        }

        async function updateStrategyStatistics() {
            try {
                const response = await fetch('/api/strategy-statistics');
                const data = await response.json();
                const container = document.getElementById('strategy-stats-content');

                if (!data.strategies || data.strategies.length === 0) {
                    container.innerHTML = '<div class="empty-state">No strategy data available</div>';
                    return;
                }

                let html = '';
                for (const strategy of data.strategies) {
                    const pnlClass = strategy.total_pnl > 0 ? 'success' :
                                   strategy.total_pnl < 0 ? 'danger' : 'neutral';
                    const pnlLabel = strategy.total_pnl > 0 ? 'Profit' :
                                    strategy.total_pnl < 0 ? 'Loss' : 'Break Even';

                    html += `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: var(--accent-2); margin-bottom: 12px; font-size: 1rem;">
                                ${strategy.strategy_name === 'None' ? 'No Strategy (Legacy)' : strategy.strategy_name}
                            </h3>
                            <div class="grid">
                                <div class="card">
                                    <div class="card-title">Markets</div>
                                    <div class="metric">${strategy.total_markets}</div>
                                </div>
                                <div class="card">
                                    <div class="card-title">Successful</div>
                                    <div class="metric">${strategy.successful_trades}</div>
                                </div>
                                <div class="card">
                                    <div class="card-title">Unsuccessful</div>
                                    <div class="metric">${strategy.unsuccessful_trades}</div>
                                </div>
                                <div class="card">
                                    <div class="card-title">PNL</div>
                                    <div class="metric">$${strategy.total_pnl.toFixed(2)}</div>
                                    <div class="badge-chip ${pnlClass}">${pnlLabel}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html;
            } catch (error) {
                console.error('Error updating strategy statistics:', error);
                document.getElementById('strategy-stats-content').innerHTML =
                    '<div class="empty-state">Error loading strategy statistics</div>';
            }
        }

        async function updateAll() {
            await Promise.all([
                updateStatus(),
                updateStatistics(),
                updateStrategyStatistics(),
                updateMarkets(),
                updateOrders(),
                updateLogs()
            ]);
            ensureCountdownTimer();
            refreshCountdowns();
            refreshLoopProgress();
        }

        function refreshLoopProgress() {
            if (!loopMeta.interval) return;
            const bar = document.getElementById('loop-progress');
            const eta = document.getElementById('loop-eta');
            if (!bar || !eta) return;

            const intervalMs = (loopMeta.interval || 0) * 1000;
            if (!intervalMs) {
                bar.style.width = '0%';
                eta.textContent = 'Next run in --';
                return;
            }

            const now = Date.now();
            const last = loopMeta.last ? new Date(loopMeta.last).getTime() : now;
            let next = loopMeta.next ? new Date(loopMeta.next).getTime() : last + intervalMs;
            if (next <= last) next = last + intervalMs;

            const progress = Math.min(1, Math.max(0, (now - last) / intervalMs));
            const remainingMs = Math.max(0, next - now);
            const remainingSec = Math.round(remainingMs / 1000);
            const mins = Math.floor(remainingSec / 60);
            const secs = remainingSec % 60;
            const pad = (n) => n.toString().padStart(2, '0');

            bar.style.width = `${(progress * 100).toFixed(0)}%`;
            eta.textContent = isBotRunning
                ? `Next run in ${pad(mins)}:${pad(secs)}`
                : 'Bot stopped';
        }

        function updateLoopUi() {
            const nextEl = document.getElementById('loop-next');
            if (!nextEl) return;
            if (loopMeta.next) {
                nextEl.textContent = formatTime(loopMeta.next);
            } else if (loopMeta.last && loopMeta.interval) {
                const fallback = new Date(new Date(loopMeta.last).getTime() + loopMeta.interval * 1000);
                nextEl.textContent = formatTime(fallback.toISOString());
            } else {
                nextEl.textContent = isBotRunning ? 'Calculating...' : '--';
            }
        }

        updateAll();
        setInterval(updateAll, 10000);
        setInterval(updateStatistics, 30000);
        setInterval(updateStrategyStatistics, 30000);
        setInterval(updateLogs, 60000);
    </script>
</body>
</html>
